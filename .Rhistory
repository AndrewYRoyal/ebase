plotDT <- bList$predictions[period == 'performance' & meterID == 'I',
.(Actual = sum(elct), Predicted = sum(MLpElct)),
by = .(date)]
plotDT[, c('Actual', 'Predicted'):= lapply(.SD, function(x) (x - mean(x))/sd(x)),
.SDcols = c('Actual', 'Predicted')]
eucDist <- sqrt(sum(plotDT[, (Actual - Predicted)^2]))
dygraph(plotDT)
eucDist
bList$predictions[period == 'performance' & meterID == 'I',
.(min(date) - min(date))]
bList$predictions
bList$predictions[period == 'performance',
.(max(date) - min(date)), by = .(meterID)]
bList$predictions[period == 'baseline',
.(max(date) - min(date)), by = .(meterID)]
plotDT <- bList$predictions[period == 'performance' & meterID == 'I',
.(Actual = sum(elct), Predicted = sum(MLpElct)),
by = .(date)]
plotDT[, c('Actual', 'Predicted'):= lapply(.SD, function(x) (x - mean(x))/sd(x)),
.SDcols = c('Actual', 'Predicted')]
eucDist <- sqrt(sum(plotDT[, (Actual - Predicted)^2]))
dygraph(plotDT)
eucDist
plot(bList)
bList$predictions
regDT <- bList$predictions[meterID == 'I', .(date, hr, elct, temp, period, mm)]
regDT
baselineM <- xgb.DMatrix(
data = sparse.model.matrix(elct ~ ., data = regDT[period == 'baseline',
-c('meterID', 'period', 'date', 'hr')]),
label = regDT[period == 'baseline', elct]
)
regDT <- bList$predictions[meterID == 'I', .(meterID, date, hr, elct, temp, period, mm)]
regDT
baselineM <- xgb.DMatrix(
data = sparse.model.matrix(elct ~ ., data = regDT[period == 'baseline',
-c('meterID', 'period', 'date', 'hr')]),
label = regDT[period == 'baseline', elct]
)
regDT
baselineM
nIterate <- xgb.cv(data = baselineM,
nfold = 5, max_depth = 5, eta = .1, nthread = 8, nrounds = 2000,
early_stopping_rounds = 3, objective = 'reg:linear', verbose = 0)$best_iteration
nIterate
nIterate <- xgb.cv(data = baselineM,
nfold = 5, max_depth = 5, eta = .05, nthread = 8, nrounds = 2000,
early_stopping_rounds = 3, objective = 'reg:linear', verbose = 0)$best_iteration
nIterate
?xgb.train()
regDT
regDT[period == 'baseline', block:= min(date) + (min(date) - max(date))/2]
regDT
regDT[period == 'baseline', block:= min(date) + (max(date) - min(date))/2]
regDT
regDT[period == 'baseline',
block:= c(1, 2)[as.numeric(date < min(date) + (max(date) - min(date))/2) + 1]
]
regDT
regDT[period == 'baseline',
block:= c(1, 2)[as.numeric(date < (min(date) + (max(date) - min(date))/2)) + 1]]
regDT
bList$predictions[meterID == 'I', .(meterID, date, hr, elct, temp, period, mm)]
regDT <- bList$predictions[meterID == 'I', .(meterID, date, hr, elct, temp, period, mm)]
regDT[period == 'baseline',
block:= c(1, 2)[as.numeric(date < (min(date) + (max(date) - min(date))/2)) + 1]]
regDT
regDT[period == 'baseline',
block:= c(1, 2)[as.numeric(date > (min(date) + (max(date) - min(date))/2)) + 1]]
regDT
matrixList <- lapply(
1:2, function(b)
xgb.DMatrix(
data = sparse.model.matrix(elct ~ ., data = regDT[period == 'baseline' & block == b,
-c('meterID', 'period', 'date', 'hr')]),
label = regDT[period == 'baseline' & block == b, elct])
)
matrixList
7824/24
?xgb.cv()
install.packages('mlr')
library('mlr')
parallelMap::parallelStart(mode = 'socket', cpus = 4, level = 'mlr.tuneParams')
3:6*50
regDT
regTask <- makeRegrTask(id = 'reg',
data = regDT[period == 'baseline', -c('date', 'hr', 'year')],
target = 'elct')
regDT[period == 'baseline', -c('date', 'hr')]
regTask <- makeRegrTask(id = 'reg',
data = regDT[period == 'baseline', -c('date', 'hr', 'period', 'meterID')],
target = 'elct')
regTask
?makeFixedHoldoutInstance
?tuneParams()
blockA <- rownames(regDT[block == 1,])
blockA
blockB <- rownames(regDT[block == 2,])
blockB
regDT[block == 1,]
[block == 2,]
[block == 2,]
regDT[block == 2,]
regDT[block == 1,]
regDT[block == 1, .n]
regDT[, index:= rownames(regDT)]
regDT
blockA <- regDT[block == 1, index]
blockA
blockB <- regDT[block == 2, index]
blockB
regTask <- makeRegrTask(id = 'reg',
data = regDT[period == 'baseline', -c('date', 'hr', 'period', 'meterID', 'block')],
target = 'elct')
regTask <- makeRegrTask(id = 'reg',
data = regDT[period == 'baseline', -c('date', 'hr', 'period', 'meterID', 'block', 'index')],
target = 'elct')
regTask <- makeRegrTask(id = 'reg',
data = regDT[period == 'baseline',
-c('date', 'hr', 'period', 'meterID', 'block', 'index')],
target = 'elct')
regTask
methods(class(regTask))
summary(regTask)
regDT[period == 'baseline',
-c('date', 'hr', 'period', 'meterID', 'block', 'index')]
regDT
regDT[, tow:= .GRP, by = .(dow(date), hr)]
regDT
?strftime()
regDT[, tow:= .GRP, by = .(strftime(date, '%u'), hr)]
regDT
summary(regDT[, tow])
regTask <- makeRegrTask(id = 'reg',
data = regDT[period == 'baseline',
-c('date', 'hr', 'period', 'meterID', 'block', 'index')],
target = 'elct')
makeFixedHoldoutInstance(train.inds = blockA, test.inds = blockB)
regDT <- bList$predictions[meterID == 'I', .(meterID, date, hr, elct, temp, period, mm)]
regDT[period == 'baseline',
block:= c(1, 2)[as.numeric(date > (min(date) + (max(date) - min(date))/2)) + 1]]
regDT[, index:= as.numeric(rownames(regDT))]
blockA <- regDT[block == 1, index]
blockB <- regDT[block == 2, index]
regDT[, tow:= .GRP, by = .(strftime(date, '%u'), hr)]
regTask <- makeRegrTask(id = 'reg',
data = regDT[period == 'baseline',
-c('date', 'hr', 'period', 'meterID', 'block', 'index')],
target = 'elct')
makeFixedHoldoutInstance(train.inds = blockA, test.inds = blockB)
max(blockA, blockB)
makeFixedHoldoutInstance(train.inds = blockA, test.inds = blockB, size = max(blockA, blockB))
rIn <- makeFixedHoldoutInstance(train.inds = blockA, test.inds = blockB, size = max(blockA, blockB))
rIn
mlr::getLearnerParamSet('regr.xgboost')
2*1:2/10
paramSpace <- makeParamSet(
makeDiscreteParam('max_depth', values = 3:8),
makeDiscreteParam('early_stopping_rounds', values = 5),
makeDiscreteParam('eta', values = 2*1:2/10))
ctrl <- makeTuneControlGrid()
tuner <- tuneParams(
learner = 'regr.xgboost',
task = regTask,
resampling = rSampleDesc,
par.set = paramSpace,
control = ctrl)
parallelMap::parallelStop()
rSampleDesc <- makeResampleDesc('CV', iters = 10)
# Tune Parameters
parallelMap::parallelStart(mode = 'socket', cpus = 4, level = 'mlr.tuneParams')
#mlr::getLearnerParamSet('regr.xgboost')
paramSpace <- makeParamSet(
makeDiscreteParam('max_depth', values = 3:8),
makeDiscreteParam('early_stopping_rounds', values = 5),
makeDiscreteParam('eta', values = 2*1:2/10))
ctrl <- makeTuneControlGrid()
rSampleDesc <- makeResampleDesc('CV', iters = 10)
tuner <- tuneParams(
learner = 'regr.xgboost',
task = regTask,
resampling = rSampleDesc,
par.set = paramSpace,
control = ctrl)
parallelMap::parallelStop()
xgbLearn <- setHyperPars(
makeLearner('regr.xgboost', verbose = 1, nthread = 8),
par.vals = tuner$x)
tuner
# Tune Parameters
parallelMap::parallelStart(mode = 'socket', cpus = 4, level = 'mlr.tuneParams')
#mlr::getLearnerParamSet('regr.xgboost')
paramSpace <- makeParamSet(
makeDiscreteParam('max_depth', values = 3:8),
makeDiscreteParam('early_stopping_rounds', values = 5),
makeDiscreteParam('nrounds', values = 2000),
makeDiscreteParam('eta', values = 2*1:2/10))
ctrl <- makeTuneControlGrid()
rSampleDesc <- makeResampleDesc('CV', iters = 10)
tuner <- tuneParams(
learner = 'regr.xgboost',
task = regTask,
resampling = rSampleDesc,
par.set = paramSpace,
control = ctrl)
parallelMap::parallelStop()
# Tune Parameters
parallelMap::parallelStart(mode = 'socket', cpus = 4, level = 'mlr.tuneParams')
#mlr::getLearnerParamSet('regr.xgboost')
paramSpace <- makeParamSet(
makeDiscreteParam('max_depth', values = 3:8),
makeDiscreteParam('early_stopping_rounds', values = 5),
makeDiscreteParam('nrounds', values = 2000),
makeDiscreteParam('verbose', values = 1),
makeDiscreteParam('eta', values = 2*1:2/10))
ctrl <- makeTuneControlGrid()
rSampleDesc <- makeResampleDesc('CV', iters = 10)
tuner <- tuneParams(
learner = 'regr.xgboost',
task = regTask,
resampling = rSampleDesc,
par.set = paramSpace,
control = ctrl)
parallelMap::parallelStop()
# Tune Parameters
parallelMap::parallelStart(mode = 'socket', cpus = 4, level = 'mlr.tuneParams')
#mlr::getLearnerParamSet('regr.xgboost')
paramSpace <- makeParamSet(
makeDiscreteParam('max_depth', values = c(3, 5, 8)),
makeDiscreteParam('early_stopping_rounds', values = 5),
makeDiscreteParam('nrounds', values = c(100, 500, 1000)),
makeDiscreteParam('eta', values = .05))
ctrl <- makeTuneControlGrid()
rSampleDesc <- makeResampleDesc('CV', iters = 2)
tuner <- tuneParams(
learner = 'regr.xgboost',
task = regTask,
resampling = rSampleDesc,
par.set = paramSpace,
control = ctrl)
parallelMap::parallelStop()
# Tune Parameters
parallelMap::parallelStart(mode = 'socket', cpus = 4, level = 'mlr.tuneParams')
#mlr::getLearnerParamSet('regr.xgboost')
paramSpace <- makeParamSet(
makeDiscreteParam('max_depth', values = c(3, 5, 8)),
makeDiscreteParam('nrounds', values = c(100, 500, 1000)),
makeDiscreteParam('eta', values = .05))
ctrl <- makeTuneControlGrid()
rSampleDesc <- makeResampleDesc('CV', iters = 2)
tuner <- tuneParams(
learner = 'regr.xgboost',
task = regTask,
resampling = rSampleDesc,
par.set = paramSpace,
control = ctrl)
parallelMap::parallelStop()
tuner
# Tune Parameters
parallelMap::parallelStart(mode = 'socket', cpus = 4, level = 'mlr.tuneParams')
#mlr::getLearnerParamSet('regr.xgboost')
paramSpace <- makeParamSet(
makeDiscreteParam('max_depth', values = c(3, 5, 8)),
makeDiscreteParam('nrounds', values = c(100, 500, 1000)),
makeDiscreteParam('eta', values = .1))
ctrl <- makeTuneControlGrid()
rSampleDesc <- makeResampleDesc('CV', iters = 2)
tuner <- tuneParams(
learner = 'regr.xgboost',
task = regTask,
resampling = rSampleDesc,
par.set = paramSpace,
control = ctrl)
parallelMap::parallelStop()
tuner
parallelMap::parallelStart(mode = 'socket', cpus = 4, level = 'mlr.tuneParams')
#mlr::getLearnerParamSet('regr.xgboost')
paramSpace <- makeParamSet(
makeDiscreteParam('max_depth', values = c(3, 5, 8)),
makeDiscreteParam('nrounds', values = c(500, 1000, 1500)),
makeDiscreteParam('eta', values = .1))
ctrl <- makeTuneControlGrid()
rSampleDesc <- makeResampleDesc('CV', iters = 2)
tuner <- tuneParams(
learner = 'regr.xgboost',
task = regTask,
resampling = rSampleDesc,
par.set = paramSpace,
control = ctrl)
parallelMap::parallelStop()
tuner
# Tune Parameters
parallelMap::parallelStart(mode = 'socket', cpus = 4, level = 'mlr.tuneParams')
#mlr::getLearnerParamSet('regr.xgboost')
paramSpace <- makeParamSet(
makeDiscreteParam('max_depth', values = c(3, 5, 8)),
makeDiscreteParam('nrounds', values = c(500, 1000, 1500)),
makeDiscreteParam('eta', values = .1))
ctrl <- makeTuneControlGrid()
rSampleDesc <- makeResampleDesc('CV', iters = 2)
rIn <- makeFixedHoldoutInstance(train.inds = blockA, test.inds = blockB, size = max(blockA, blockB))
tuner <- tuneParams(
learner = 'regr.xgboost',
task = regTask,
# resampling = rSampleDesc,
resampling = rIn,
par.set = paramSpace,
control = ctrl)
parallelMap::parallelStop()
tuner
parallelMap::parallelStart(mode = 'socket', cpus = 4, level = 'mlr.tuneParams')
#mlr::getLearnerParamSet('regr.xgboost')
paramSpace <- makeParamSet(
makeDiscreteParam('max_depth', values = c(3, 5)),
makeDiscreteParam('nrounds', values = c(200, 400, 600, 800, 1000)),
makeDiscreteParam('eta', values = .1))
ctrl <- makeTuneControlGrid()
rSampleDesc <- makeResampleDesc('CV', iters = 2)
rIn <- makeFixedHoldoutInstance(train.inds = blockA, test.inds = blockB, size = max(blockA, blockB))
tuner <- tuneParams(
learner = 'regr.xgboost',
task = regTask,
# resampling = rSampleDesc,
resampling = rIn,
par.set = paramSpace,
control = ctrl)
parallelMap::parallelStop()
tuner
?subsetTask()
xgbLearn <- setHyperPars(
makeLearner('regr.xgboost', verbose = 1, nthread = 8),
par.vals = tuner$x)
xgbLearn
?makeResampleDesc
max(c(blockA, blockB))
regDT
regDT
regDT <- bList$predictions[meterID == 'I', .(meterID, date, hr, elct, temp, period, mm)]
regDT[period == 'baseline',
block:= c(1, 2)[as.numeric(date > (min(date) + (max(date) - min(date))/2)) + 1]]
regDT[, index:= as.numeric(rownames(regDT))]
blockA <- regDT[block == 1, index]
blockB <- regDT[block == 2, index]
regDT[, tow:= .GRP, by = .(strftime(date, '%u'), hr)]
regTask <- makeRegrTask(id = 'reg',
data = regDT[period == 'baseline',
-c('date', 'hr', 'period', 'meterID', 'block', 'index')],
target = 'elct')
# Tune Parameters
parallelMap::parallelStart(mode = 'socket', cpus = 4, level = 'mlr.tuneParams')
#mlr::getLearnerParamSet('regr.xgboost')
paramSpace <- makeParamSet(
makeDiscreteParam('max_depth', values = c(3, 5)),
makeDiscreteParam('nrounds', values = c(200, 400, 600, 800, 1000)),
makeDiscreteParam('eta', values = .1))
ctrl <- makeTuneControlGrid()
rSampleDesc <- makeResampleDesc('CV', iters = 2)
rIn <- makeFixedHoldoutInstance(train.inds = blockA,
test.inds = blockB,
size = max(c(blockA, blockB)))
tuner <- tuneParams(
learner = 'regr.xgboost',
task = regTask,
resampling = rIn,
par.set = paramSpace,
control = ctrl)
parallelMap::parallelStop()
xgbLearn <- setHyperPars(
makeLearner('regr.xgboost', verbose = 1, nthread = 8),
par.vals = tuner$x)
xgbModel <- train(learner = xgbLearn, task = regTask)
x <- predict(xgbModel, newdata = regDT[, -c('date', 'hr', 'year')])
mlr::getLearnerParamSet('regr.xgboost')
regDT <- bList$predictions[meterID == 'I', .(meterID, date, hr, elct, temp, period, mm)]
regDT[period == 'baseline',
block:= c(1, 2)[as.numeric(date > (min(date) + (max(date) - min(date))/2)) + 1]]
regDT[, index:= as.numeric(rownames(regDT))]
blockA <- regDT[block == 1, index]
blockB <- regDT[block == 2, index]
regDT[, tow:= .GRP, by = .(strftime(date, '%u'), hr)]
regTask <- makeRegrTask(id = 'reg',
data = regDT[period == 'baseline',
-c('date', 'hr', 'period', 'meterID', 'block', 'index')],
target = 'elct')
# Tune Parameters
parallelMap::parallelStart(mode = 'socket', cpus = 4, level = 'mlr.tuneParams')
#mlr::getLearnerParamSet('regr.xgboost')
paramSpace <- makeParamSet(
makeDiscreteParam('max_depth', values = c(3, 5)),
makeDiscreteParam('nrounds', values = c(200, 400, 600, 800, 1000)),
makeDiscreteParam('early_stopping_rounds', values = 5),
makeDiscreteParam('eta', values = .1))
ctrl <- makeTuneControlGrid()
rSampleDesc <- makeResampleDesc('CV', iters = 2)
rIn <- makeFixedHoldoutInstance(train.inds = blockA,
test.inds = blockB,
size = max(c(blockA, blockB)))
tuner <- tuneParams(
learner = 'regr.xgboost',
task = regTask,
resampling = rIn,
par.set = paramSpace,
control = ctrl)
parallelMap::parallelStop()
xgbLearn <- setHyperPars(
makeLearner('regr.xgboost', verbose = 1, nthread = 8),
par.vals = tuner$x)
xgbModel <- train(learner = xgbLearn, task = regTask)
xgbModel
x <- predict(xgbModel, newdata = regDT[, -c('date', 'hr', 'year')])
regDT
xgbModel
summary(xgbModel)
names(summary(xgbModel))
xgbModel$features
regDT
x <- predict(xgbModel, newdata = regDT[, .(temp, mm, tow)])
x
with(x$data,
mean((truth - response)^2))
x$data
regDT
x <- predict(xgbModel, newdata = regDT[, .(elct, temp, mm, tow)])
x
cbind(regDT[, .(date, hr)], x$data)
cbind(regDT[, .(date, hr)], x$data)
dygraphs(cbind(regDT[, .(date, hr)], x$data))
dygraph(cbind(regDT[, .(date, hr)], x$data))
dygraph(
cbind(regDT[, .(date, hr)], x$data)[, .(Actual = sum(truth), Predicted = sum(response)), by = .(date)])
plotDT <- cbind(regDT[, .(date, hr)], x$data)[, .(Actual = sum(truth), Predicted = sum(response)), by = .(date)]
plotDT
plotDT[, c('Actual', 'Predicted'):= lapply(.SD, function(x) (x - mean(x))/sd(x))]
plotDT[, c('Actual', 'Predicted'):= lapply(.SD, function(x) (x - mean(x))/sd(x)),
.SDcols = c('Actual', 'Predicted')]
plotDT <- cbind(regDT[, .(date, hr)], x$data)[, .(Actual = sum(truth), Predicted = sum(response)), by = .(date)]
plotDT[, c('Actual', 'Predicted'):= lapply(.SD, function(x) (x - mean(x))/sd(x)),
.SDcols = c('Actual', 'Predicted')]
plotDT
plotDT <- cbind(regDT[, .(date, hr, period)], x$data)[, .(Actual = sum(truth), Predicted = sum(response)), by = .(date)]
plotDT[, c('Actual', 'Predicted'):= lapply(.SD, function(x) (x - mean(x))/sd(x)),
.SDcols = c('Actual', 'Predicted')]
plotDT
plotDT <- cbind(regDT[, .(date, hr, period)], x$data)[, .(Actual = sum(truth), Predicted = sum(response)), by = .(date)]
plotDT[period == 'performance', c('Actual', 'Predicted'):= lapply(.SD, function(x) (x - mean(x))/sd(x)),
.SDcols = c('Actual', 'Predicted')]
regDT
plotDT <- cbind(regDT[, .(date, hr, period)], x$data)[, .(Actual = sum(truth), Predicted = sum(response)), by = .(date)]
plotDT
plotDT <- cbind(regDT[, .(date, hr, period)], x$data)[, .(Actual = sum(truth), Predicted = sum(response)),
by = .(date, period)]
plotDT
plotDT[period == 'performance', ]
plotDT[, c('Actual', 'Predicted'):= lapply(.SD, function(x) (x - mean(x))/sd(x)),
.SDcols = c('Actual', 'Predicted')]
plotDT <- cbind(regDT[, .(date, hr, period)], x$data)[, .(Actual = sum(truth), Predicted = sum(response)),
by = .(date, period)]
plotDT <- plotDT[period == 'performance', ]
plotDT[, c('Actual', 'Predicted'):= lapply(.SD, function(x) (x - mean(x))/sd(x)),
.SDcols = c('Actual', 'Predicted')]
plotDT
eucDist <- sqrt(sum(plotDT[, (Actual - Predicted)^2]))
eucDist
plotDT
dygraph(plotDT)
eucDist
regDT <- bList$predictions[meterID == 'J', .(meterID, date, hr, elct, temp, period, mm)]
regDT[period == 'baseline',
block:= c(1, 2)[as.numeric(date > (min(date) + (max(date) - min(date))/2)) + 1]]
regDT[, index:= as.numeric(rownames(regDT))]
blockA <- regDT[block == 1, index]
blockB <- regDT[block == 2, index]
regDT[, tow:= .GRP, by = .(strftime(date, '%u'), hr)]
regTask <- makeRegrTask(id = 'reg',
data = regDT[period == 'baseline',
-c('date', 'hr', 'period', 'meterID', 'block', 'index')],
target = 'elct')
# Tune Parameters
parallelMap::parallelStart(mode = 'socket', cpus = 4, level = 'mlr.tuneParams')
#mlr::getLearnerParamSet('regr.xgboost')
paramSpace <- makeParamSet(
makeDiscreteParam('max_depth', values = c(3, 5)),
makeDiscreteParam('nrounds', values = c(200, 400, 600, 800, 1000)),
makeDiscreteParam('early_stopping_rounds', values = 5),
makeDiscreteParam('eta', values = .1))
ctrl <- makeTuneControlGrid()
rSampleDesc <- makeResampleDesc('CV', iters = 2)
rIn <- makeFixedHoldoutInstance(train.inds = blockA,
test.inds = blockB,
size = max(c(blockA, blockB)))
tuner <- tuneParams(
learner = 'regr.xgboost',
task = regTask,
resampling = rIn,
par.set = paramSpace,
control = ctrl)
parallelMap::parallelStop()
xgbLearn <- setHyperPars(
makeLearner('regr.xgboost', verbose = 1, nthread = 8),
par.vals = tuner$x)
xgbModel <- train(learner = xgbLearn, task = regTask)
x <- predict(xgbModel, newdata = regDT[, .(elct, temp, mm, tow)])
with(x$data,
mean((truth - response)^2))
plotDT <- cbind(regDT[, .(date, hr, period)], x$data)[, .(Actual = sum(truth), Predicted = sum(response)),
by = .(date, period)]
plotDT <- plotDT[period == 'performance', ]
plotDT[, c('Actual', 'Predicted'):= lapply(.SD, function(x) (x - mean(x))/sd(x)),
.SDcols = c('Actual', 'Predicted')]
eucDist <- sqrt(sum(plotDT[, (Actual - Predicted)^2]))
dygraph(plotDT)
eucDist
